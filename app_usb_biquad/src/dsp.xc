/******************************************************************************\
 * File:	dsp.xc
 * Author: Mark Beaumont
 * Description: Definitions, types, and prototypes for dsp.xc
 *
 * Version: 3v3rc1
 * Build:
 *
 * The copyrights, all other intellectual and industrial
 * property rights are retained by XMOS and/or its licensors.
 * Terms and conditions covering the use of this code can
 * be found in the Xmos End User License Agreement.
 *
 * Copyright XMOS Ltd 2012
 *
 * In the case where this code is a modification of existing code
 * under a separate license, the separate license terms are shown
 * below. The modifications to the code are still covered by the
 * copyright notice above.
 *
\******************************************************************************/

#include "dsp.h"

// DSP thread.

#include <xs1.h>
#include <safestring.h>
#include "devicedefines.h"
#include <print.h>
#include "coeffs.h"
#include "biquadCascade.h"
#include "biquad_simple.h"

extern int biquadAsm( int xn ,biquadState &state );

// BANKS is defined in coeffs.h and generated by makefile.

/******************************************************************************/
// The change_dsp funcion simply iterates over some presets to demonstrate
// the sorts of possible effects.
// These are chosen for being easily noticed, rather than providing
// subtle sound quality improvements.
// The program assumes that the Bass shelf filter is the first value in the Makefile generation
// and the treble shelf is the second value. Putting the filters in a different order in the makefile
// will change the effects here.

#pragma unsafe arrays
void change_dsp(
	biquadState &bq,
	int eq_select
)
{
	int bank_cnt; // Bank counter


	switch(eq_select)
	{
		case 0: // "Off"
#pragma loop unroll
		for (bank_cnt=0; bank_cnt<BANKS; bank_cnt++) 
		{
			bq.desiredDb[bank_cnt] = 20 ; //zeroDb value
		} // for bank_cnt
		break;
	
		case 1: // Bass boost only
#pragma loop unroll
		for (bank_cnt=0; bank_cnt<BANKS; bank_cnt++) 
		{
			bq.desiredDb[bank_cnt] = 20; // zeroDb value
		} // for bank_cnt
		bq.desiredDb[0] = 30; // Set bass filter to boost
		break;
	
		case 2: // Treble boost only
#pragma loop unroll
		for (bank_cnt=0; bank_cnt<BANKS; bank_cnt++) 
		{
			bq.desiredDb[bank_cnt] = 20; // zeroDb value
		} // for bank_cnt
		bq.desiredDb[1] = 30; // set treble filter to boost
		break;
	
		case 3: // bass boost, treble boost + all peaking filters (All filters turned on).
		// As the number of filters defined in the makefile increase, it is
		// suggeted you reduce desiredDb towards 20 (no change) to minimise
		// distortion.
		// With 5 banks, a setting of 30 is okay for most music types
		// With 10 banks, a setting of 25 is okay for most music types
#pragma loop unroll
		for (bank_cnt=0; bank_cnt<BANKS; bank_cnt++)
		{
			bq.desiredDb[bank_cnt] = 25;
		} // for bank_cnt
		break;
	
		default:
		 break;
	} // switch(eq_select)
} // change_dsp
/******************************************************************************/
//give/get functions based on mixer.xc then simplified.

#pragma unsafe arrays
void give_samples_to_host(
	chanend c_out, // audio-out channel
	const int samples[] // samples
)
{
	int chan_cnt; // channel counter


#pragma loop unroll
	for (chan_cnt=0; chan_cnt<NUM_USB_CHAN_IN; chan_cnt++)
	{
		int sample;

		sample = samples[chan_cnt];

		outuint( c_out ,sample ); // Transmit sample to De-coupler
	} // for chan_cnt
} // give_samples_to_host
/******************************************************************************/
#ifdef MB
#pragma unsafe arrays
static void get_samples_from_host_old(
	chanend c_inp, // audio-in channel
	int samples[],
	biquadState bs[]
)
{
	int chan_cnt; // channel counter
	unsigned int l_samp[NUM_USB_CHAN_OUT];


#pragma loop unroll
	for (chan_cnt=0; chan_cnt<NUM_USB_CHAN_OUT; chan_cnt++)
	{
		int sample;

		l_samp[chan_cnt] = inuint( c_inp ); // Receive sample from decouple
	} // for chan_cnt

	// timing fails if we do dsp in between receiving for both channels.
	// Instead receive into a local buffer, then do the dsp on both channels.
	// XTA times a single call to biquadAsm as 234 thread cycles with 4 banks.
	// 48000 sample freq * 2 channels => ~100000 operations/second or 10us
	// allowance between samples.
	// With an 80 MIPS thread speed (500MHz/6 threads), this gives ~36 cascaded biquads as the
	// maximum number possible at a max sample freq of 48kHz (ie BANKS=18).

#pragma loop unroll
	for (chan_cnt=0; chan_cnt<NUM_USB_CHAN_OUT; chan_cnt++)
	{
		int sample;

		sample = biquadAsm( (l_samp[chan_cnt] >> 8) ,bs[chan_cnt] );

		samples[chan_cnt] = (sample << 8);
	} // for chan_cnt
} // get_samples_from_host_old
#endif // MB~
/******************************************************************************/

#pragma unsafe arrays
static void get_samples_from_host(
	chanend c_inp, // audio-in channel
	int samples[], // Array of output samples
	int sampFreq  // current sample frequency
)
{
	int chan_cnt; // channel counter
	unsigned int l_samp[NUM_USB_CHAN_OUT];


#pragma loop unroll
	for (chan_cnt=0; chan_cnt<NUM_USB_CHAN_OUT; chan_cnt++)
	{
		l_samp[chan_cnt] = inuint( c_inp ); // Receive sample from decouple
	} // for chan_cnt

	// timing fails if we do dsp in between receiving for both channels.
	// Instead receive into a local buffer, then do the dsp on both channels.
	// XTA times a single call to biquadAsm as 234 thread cycles with 4 banks.
	// 48000 sample freq * 2 channels => ~100000 operations/second or 10us
	// allowance between samples.
	// With an 80 MIPS thread speed (500MHz/6 threads), this gives ~36 cascaded biquads as the
	// maximum number possible at a max sample freq of 48kHz (ie BANKS=18).

#pragma loop unroll
	for (chan_cnt=0; chan_cnt<NUM_USB_CHAN_OUT; chan_cnt++)
	{
		samples[chan_cnt] = biquad_filter_wrapper( l_samp[chan_cnt] ,chan_cnt ,sampFreq );
//	samples[chan_cnt] = l_samp[chan_cnt];
	} // for chan_cnt
} // get_samples_from_host
/******************************************************************************/
#pragma unsafe arrays
void give_samples_to_device(
	chanend c_out, // audio-out channel 
	const int samples[] 
)
{
	int chan_cnt; // channel counter

#pragma loop unroll
	for (chan_cnt=0; chan_cnt<NUM_USB_CHAN_OUT; chan_cnt++)
	{
		int sample;

		sample = samples[chan_cnt];
		outuint( c_out ,sample ); // Transmit sample to Audio Driver
	} // for chan_cnt
} // give_samples_to_device
/******************************************************************************/
#pragma unsafe arrays
void get_samples_from_device(
	chanend c_inp, // audio-in channel 
	int samples[]
)
{
	int chan_cnt; // channel counter

#pragma loop unroll
	for (chan_cnt=0; chan_cnt<NUM_USB_CHAN_IN; chan_cnt++)
	{
		int sample;

		sample = inuint( c_inp );
		samples[chan_cnt] = sample; // Receive sample from Audio-Driver
	} // chan_cnt
} // get_samples_from_device
/******************************************************************************/
void dsp( // processes audio stream using dsp functions
	chanend c_aud_in, // Input audio stream
	chanend c_aud_out, // Output audio stream
	in port p_button_a, // 1st Input button for selecting DSP functions
	in port p_button_b // 2nd Input button for selecting DSP functions
)
{
	int inp_samples[NUM_USB_CHAN_IN]; // array of samples for each input channel
	int out_samples[NUM_USB_CHAN_OUT]; // array of samples for each output channel

	biquadState bs_old[NUM_USB_CHAN_OUT];
	timer timr_a;
	timer timr_b;
	unsigned time_a;
	unsigned time_b;
	unsigned button_a_val = 0;
	unsigned button_a_active = 1;
	unsigned biquad_offset = 0;
	unsigned button_b_active = 1;
	unsigned button_b_val = 0;
	unsigned bass_filter = 10;
	unsigned chan_cnt; // Channel counter
	int sampFreq; // current sample frequency

//MB~	int samp_freq = get_status(  SAMPLE_FREQUENCY );

	// 20 is the central value (approx no-eq).
	// As values tend to the extremes, distortion will become more prevalent.
	// The spread of available values is defined in the Makefile where the filter coefficients are set.
	// If a smaller coefficient array is used, these values will need to be adjusted.

	for (chan_cnt=0; chan_cnt<NUM_USB_CHAN_OUT; chan_cnt++)
	{
		initBiquads( bs_old[chan_cnt] ,20 );
	} // for chan_cnt

	set_port_inv (p_button_a);
	set_port_inv (p_button_b);

	// zero sample buffers.
	safememset( (inp_samples ,unsigned char[]) ,0 ,(NUM_USB_CHAN_IN * sizeof( int )) ); 
	safememset( (out_samples ,unsigned char[]) ,0 ,(NUM_USB_CHAN_OUT * sizeof( int )) ); 

	while (1) 
	{
		inuint( c_aud_out );
	
		// Request data from decouple thread 
		outuint( c_aud_in ,0 );
	
		if (testct( c_aud_in )) 
		{
			// sample frequency change.
			inct( c_aud_in );
			sampFreq = inuint( c_aud_in );
	
			// Send SF change to audio thread.
			outct( c_aud_out ,XS1_CT_END );
			outuint( c_aud_out ,sampFreq );

			// wait for handshake and send back
			chkct( c_aud_out ,XS1_CT_END );
			outct( c_aud_in ,XS1_CT_END );
		} // if (testct( c_aud_in )) 
		else 
		{
			// Normal audio loop.
			// Get info from host indicating we're ready and tell the audio
			// thread data is on its way.
			inuint( c_aud_in );
	
			outuint( c_aud_out ,0 );
	
			give_samples_to_device( c_aud_out ,out_samples );
			get_samples_from_device( c_aud_out ,inp_samples );
			give_samples_to_host( c_aud_in ,inp_samples );
//			get_samples_from_host_old( c_aud_in ,out_samples ,bs_old );
			get_samples_from_host( c_aud_in ,out_samples ,sampFreq );
		}; // else !(testct( c_aud_in )) 
	
		// The section below demonstrates how a user interface can
		// be used to change the EQ settings on the fly using the A and B buttons
		// on the L1 reference board.
	
		// Sample the buttons values with a timeout for debounce.
		// Button A changes the Bass shelf filter through 3 settings (cut ,normal ,boost)
		p_button_a :> button_a_val;

		if (button_a_val && button_a_active) 
		{
			bass_filter = bs_old[0].desiredDb[0];
			bass_filter += 10;

			if (bass_filter > 30) 
			{
				bass_filter = 10;
			} // if (bass_filter > 30) 

	
			for (chan_cnt=0; chan_cnt<NUM_USB_CHAN_OUT; chan_cnt++)
			{
				bs_old[chan_cnt].desiredDb[0] = bass_filter;
			} // for chan_cnt
	
			timr_a:>time_a;
			button_a_active = 0;
		} // if (button_a_val && button_a_active) 

	
		// Button B iterates over the 4 DSP presets
		// B will clear any changes made with button A.
		p_button_b :> button_b_val;

		if (button_b_val && button_b_active) 
		{
			biquad_offset ++;
			biquad_offset &= 3;
	
			for (chan_cnt=0; chan_cnt<NUM_USB_CHAN_OUT; chan_cnt++)
			{
				change_dsp( bs_old[chan_cnt] ,biquad_offset );
			} // for chan_cnt
	
			timr_b:>time_b;
			button_b_active = 0;
		} // if (button_b_val && button_b_active) 

	
		// 0.5s timeout on button press for B, 0.3s on A
		// Holding the buttons down will then iterate over the possible settings with this time period
		// between changes.
		select 
		{
			case (button_b_active == 0 ) => timr_b when timerafter (time_b + 50000000) :> int _:
				button_b_active = 1;
			break;
	
			case (button_a_active == 0 ) => timr_a when timerafter (time_a + 30000000) :> int _:
				button_a_active = 1;
			break;

			default:
			break;
		} // select 
	} // 	while (1) 
} // dsp
/******************************************************************************/
// dsp.xc
